// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/Ownable.sol";

contract LMC is Ownable {
    enum TransactionType { In, Out, Stock }

    struct TransactionData {
        TransactionType transactionType;
        uint256 tankId;
        uint256 volumeDeciliters;
        uint256 cashCents;
        string productName;
        uint256 invoiceXmlKey;
        uint256 nozzleId;
    }

    struct ProductTransaction {
        string referenceDate;
        TransactionData[] transactions;
    }

    struct AuditTransaction {
        address userAddress;
        ProductTransaction transaction;
    }

    uint256 private nextTransactionId = 1;
    mapping(uint256 => ProductTransaction) public transactionRecords;
    mapping(address => uint256[]) private userTransactions;
    mapping(address => mapping(string => bool)) private userDateRecords;
    address[] private users; // Array to keep track of all users

    constructor() Ownable(msg.sender) {}

    function recordTransaction(string memory referenceDate, TransactionData[] memory transactionsData) public {
        require(!userDateRecords[msg.sender][referenceDate], "Transaction for this date already exists.");

        // Add user to users array if not already included
        if (userTransactions[msg.sender].length == 0) {
            users.push(msg.sender);
        }

        ProductTransaction storage newTransactionRecord = transactionRecords[nextTransactionId];
        newTransactionRecord.referenceDate = referenceDate;

        for (uint256 i = 0; i < transactionsData.length; i++) {
            newTransactionRecord.transactions.push(transactionsData[i]);
        }

        userTransactions[msg.sender].push(nextTransactionId);
        userDateRecords[msg.sender][referenceDate] = true;
        nextTransactionId++;
    }

    function readTransactions() public view returns (ProductTransaction[] memory) {
        uint256[] memory transactionIds = userTransactions[msg.sender];
        ProductTransaction[] memory userTransactionData = new ProductTransaction[](transactionIds.length);

        for (uint256 i = 0; i < transactionIds.length; i++) {
            uint256 transactionId = transactionIds[i];
            ProductTransaction storage transactionRecord = transactionRecords[transactionId];
            userTransactionData[i] = transactionRecord;
        }

        return userTransactionData;
    }

    function checkRecordExists(string memory referenceDate) public view returns (bool) {
        return userDateRecords[msg.sender][referenceDate];
    }

    // Function without userAddress parameter
    function auditTransactions() public view onlyOwner returns (AuditTransaction[] memory) {
        return auditTransactionsInternal(address(0));
    }

    // Function with userAddress parameter
    function auditTransactions(address userAddress) public view onlyOwner returns (AuditTransaction[] memory) {
        return auditTransactionsInternal(userAddress);
    }

    // Internal function that performs the actual logic
    function auditTransactionsInternal(address userAddress) internal view returns (AuditTransaction[] memory) {
        uint256 totalTransactionsCount = 0;
        if (userAddress != address(0)) {
            totalTransactionsCount = userTransactions[userAddress].length;
        } else {
            for (uint256 i = 0; i < users.length; i++) {
                totalTransactionsCount += userTransactions[users[i]].length;
            }
        }

        AuditTransaction[] memory auditTransactionData = new AuditTransaction[](totalTransactionsCount);
        uint256 counter = 0;

        if (userAddress != address(0)) {
            for (uint256 i = 0; i < userTransactions[userAddress].length; i++) {
                uint256 transactionId = userTransactions[userAddress][i];
                auditTransactionData[counter] = AuditTransaction(userAddress, transactionRecords[transactionId]);
                counter++;
            }
        } else {
            for (uint256 i = 0; i < users.length; i++) {
                for (uint256 j = 0; j < userTransactions[users[i]].length; j++) {
                    uint256 transactionId = userTransactions[users[i]][j];
                    auditTransactionData[counter] = AuditTransaction(users[i], transactionRecords[transactionId]);
                    counter++;
                }
            }
        }

        return auditTransactionData;
    }
}
